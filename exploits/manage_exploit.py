#########################
## Connor Nelson, 2017 ##
#########################

import argparse
import threading

from importlib import import_module
from time import localtime, strftime
from pwn import *
from ictf import iCTF

# Seconds past tick remaining til next tick
TICK_DELAY = 5.0 

# Seconds into a tick when exploiting should begin
TICK_EXPLOIT = 30.0

# Seconds remaining in tick when flags should be submitted
TICK_SUBMIT = 20.0

LOG_LOCK = threading.Lock()

def manage_ticks(team, locks):
    internal_lock = threading.Lock()

    def new_tick():
        for lock in locks:
            try:
                lock.release()
            except threading.ThreadError:
                pass
        internal_lock.release()

    while True:
        internal_lock.acquire(True)
        tick_remaining = team.get_tick_info()['approximate_seconds_left']
        timer = threading.Timer(tick_remaining + TICK_DELAY, new_tick)
        timer.daemon = True
        timer.start()

def manage_flags(team, flags, tick_lock):
    def submit_flags():
        flag_count = len(flags)
        response = team.submit_flag(flags[:flag_count])
        log("Submitted %d flags:\n%s\nResponse:\n%s" % 
            (flag_count, flags[:flag_count], response))
        del flags[:flag_count]

    while True:
        tick_lock.acquire()
        tick_remaining = team.get_tick_info()['approximate_seconds_left']
        interval = max(tick_remaining - TICK_SUBMIT, 0)
        timer = threading.Timer(interval, submit_flags)
        timer.daemon = True
        timer.start()
            
def manage_exploit(team, session, exploit, service, flags, tick_lock):
    def exploit_service():
        targets = {t['hostname'] : t['flag_id'] for t in
                   team.get_targets(service['service_id'])['targets']}
        for hostname, flag_id in targets.items():
            log("Exploiting host %s for flag_id %s" % (hostname, flag_id))
            thread = threading.Thread(target=exploit_host, 
                                      args=(hostname, service['port'], flag_id))
            thread.daemon = True
            thread.start()        

    def exploit_host(hostname, port, flag_id):
        remote = session.connect_remote(hostname, service['port'])
        flag = exploit(remote, flag_id)
        remote.close()
        if flag:
            log("Retrieved flag from host %s for flag_id %s: %s" %
                (hostname, flag_id, flag))
            flags.append(flag)
        else:
            log("Could not retrieve flag from host %s for flag_id %s" %
                (hostname, flag_id))

    while True:
        tick_lock.acquire(True)
        timer = threading.Timer(TICK_EXPLOIT, exploit_service)
        timer.daemon = True
        timer.start()

def log(msg):
    with LOG_LOCK:
        timestamp = strftime('%H:%M:%S', time.localtime())
        print "\n[%s] %s" % (timestamp, msg)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-e', '--exploit', required=True)
    parser.add_argument('-t', '--team-interface', required=True)    
    parser.add_argument('-u', '--username', required=True)
    parser.add_argument('-p', '--password', required=True)
    parser.add_argument('-k', '--key', required=True)
    args = vars(parser.parse_args())

    log("Loading exploit...")
    try:
        exploit_module = import_module(args['exploit'])
        exploit_info = getattr(exploit_module, 'exploit_info')()
    except ImportError:
        log("Error: Could not find exploit: %s" % (args['exploit'],))
        return
    except SyntaxError:
        log("Error: syntax error in exploit")
        return
    except AttributeError:
        log("Error: could not find exploit info")
        return
    exploit_info_fields = ['exploit_function', 'service_id']
    for field in exploit_info_fields:
        if field not in exploit_info:
            log("Error: could not find exploit info for: %s" % (field,))
            return

    log("Connecting to iCTF...")
    team_interface = 'http://' + args['team_interface'] + '/'
    client = iCTF(team_interface)
    team = client.login(args['username'], args['password'])

    service_fields = ['service_name', 'service_id', 'port']
    services = [{f : s[f] for f in service_fields} for s in team.get_service_list()]
    exploit_service = None
    for service in services:
        if service['service_id'] == exploit_info['service_id']:
            exploit_service = service
            break

    if not exploit_service:
        log("Error: Could not find exploit service for service_id: %d", (service_id,))
        return
    else:
        log("Found exploit service: %s [%d] @ port %d" % (service['service_name'],
                                                          service['service_id'],
                                                          service['port']))

    log("Connecting to root through ssh...")
    keys = team.get_ssh_keys()
    session = ssh(user = 'root',
                  host = keys['ip'],
                  port = keys['port'],
                  keyfile = args['key'])

    log("Starting tick manager...")
    tick_functions = ['manage_flags', 'manage_exploit']
    tick_locks = {tf : threading.Lock() for tf in tick_functions}
    thread = threading.Thread(target=manage_ticks, args=(team, tick_locks.values()))
    thread.daemon = True
    thread.start()

    log("Starting flag submission manager...")
    flags = []
    thread = threading.Thread(target=manage_flags, 
                              args=(team, flags, tick_locks['manage_flags']))
    thread.daemon = True
    thread.start()

    log("Starting to exploit service")
    manage_exploit(team, session, exploit_info['exploit_function'], 
                   exploit_service, flags, tick_locks['manage_exploit'])

    log("Exiting...")

if __name__ == '__main__':
    main()
